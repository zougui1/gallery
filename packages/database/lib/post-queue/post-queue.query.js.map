{"version":3,"file":"post-queue.query.js","sourceRoot":"","sources":["../../src/post-queue/post-queue.query.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAiME","sourcesContent":["/*import { sort } from 'radash';\nimport type { FlattenMaps, Types } from 'mongoose';\n\nimport { PostQueueStatus, busyStatuses } from '@zougui/gallery.enums';\n\nimport { PostQueueModel, type PostQueue } from './post-queue.model';\nimport {\n  postQueueSchema,\n  type PostQueueSchema,\n  type PostQueueSchemaWithId,\n  type PostQueueStepSchema,\n} from './post-queue.schema';\n\ntype LeanPostQueue = FlattenMaps<PostQueue> & {\n  _id: Types.ObjectId;\n};\n\nexport class PostQueueQuery {\n  create = async (data: Omit<PostQueueSchema, 'steps'>): Promise<PostQueueSchemaWithId> => {\n    const document = await PostQueueModel.create(postQueueSchema.parse(data));\n    return this.deserialize(document);\n  }\n\n  findById = async (id: string): Promise<PostQueueSchemaWithId | undefined> => {\n    const document = await PostQueueModel.findById(id).lean();\n\n    if (document) {\n      return this.deserialize(document);\n    }\n  }\n\n  createMany = async (data: Omit<PostQueueSchema, 'steps'>[]): Promise<PostQueueSchemaWithId[]> => {\n    const documents = await PostQueueModel.create(data.map(d => postQueueSchema.parse(d)));\n    return sort(documents.map(this.deserialize), d => d.createdAt.getTime());\n  }\n\n  search = async (options: SearchOptions): Promise<SearchResult> => {\n    const { pageSize } = options;\n    const pageIndex = Math.max(options.page - 1, 0);\n\n    let aggregate = PostQueueModel.aggregate<SearchAggregateResult>();\n\n    if (options.status) {\n      aggregate = aggregate\n        .addFields({\n          lastStatus: {\n            $last: '$steps.status',\n          },\n        })\n        .match(options.status === PostQueueStatus.idle ? {\n          $or: [\n            { lastStatus: options.status },\n            {\n              steps: { $size: 0 },\n            }\n          ],\n        } : {\n          lastStatus: options.status,\n        });\n    }\n\n    aggregate = aggregate.facet({\n      data: [\n        {\n          $sort: { _id: -1 },\n        },\n        { $skip: pageIndex * pageSize },\n        { $limit: pageSize },\n      ],\n      count: [\n        {\n          $count: 'count',\n        },\n      ],\n    });\n\n    const [result] = await aggregate;\n\n    if (!result) {\n      return { count: 0, data: [] };\n    }\n\n    return {\n      count: result.count?.[0]?.count ?? 0,\n      data: result.data.map(this.deserialize),\n    };\n  }\n\n  findDuplicate = async ({ url }: { url: string }): Promise<PostQueueSchemaWithId | undefined> => {\n    const document = await PostQueueModel.findOne({ url }).lean();\n\n    if (document) {\n      return this.deserialize(document);\n    }\n  }\n\n  addStep = async (id: string, step: PostQueueStepSchema): Promise<void> => {\n    await PostQueueModel.findByIdAndUpdate(id, {\n      $push: {\n        steps: step,\n      },\n    });\n  }\n\n  setAlt = async (url: string, alt: NonNullable<PostQueueSchema['alt']>): Promise<void> => {\n    await PostQueueModel.updateOne({ url }, { alt });\n  }\n\n  removeAlt = async (query: { _id: string; } | { sourceUrl: string; }): Promise<void> => {\n    await PostQueueModel.updateOne(query, { $unset: { alt: 1 } });\n  }\n\n  setSeries = async (url: string, series: NonNullable<PostQueueSchema['series']>): Promise<void> => {\n    await PostQueueModel.updateOne({ url }, { series });\n  }\n\n  setAdditionalData = async (url: string, data: Partial<Pick<PostQueueSchema, 'series' | 'alt'>>): Promise<void> => {\n    await PostQueueModel.updateOne({ url }, data);\n  }\n\n  findAllKeywords = async (): Promise<string[]> => {\n    return await PostQueueModel.distinct('keywords');\n  }\n\n  findOneBusy = async (): Promise<PostQueueSchemaWithId | undefined> => {\n    const [postQueue] = await PostQueueModel\n      .aggregate<PostQueueSchemaWithId>()\n      .addFields({\n        lastStep: {\n          $last: '$steps',\n        },\n      })\n      .match({\n        'lastStep.status': {\n          $in: busyStatuses,\n        },\n      })\n      .limit(1)\n      .project({\n        lastStep: 0,\n      });\n\n    return postQueue;\n  }\n\n  findOneIdle = async (): Promise<PostQueueSchemaWithId | undefined> => {\n    const [postQueue] = await PostQueueModel\n      .aggregate<PostQueueSchemaWithId>()\n      .match({\n        'steps.0': {\n          $exists: false,\n        },\n      })\n      .sort({\n        createdAt: 1,\n      })\n      .limit(1);\n\n    return postQueue;\n  }\n\n  findBySeriesId = async (id: string): Promise<PostQueueSchemaWithId[]> => {\n    const documents = await PostQueueModel.find({ 'series.id': id }).lean();\n    return documents.map(this.deserialize);\n  }\n\n  deleteById = async (id: string): Promise<void> => {\n    await PostQueueModel.findByIdAndDelete(id);\n  }\n\n  private deserialize = (document: LeanPostQueue): PostQueueSchemaWithId => {\n    return {\n      ...postQueueSchema.parse(document),\n      _id: document._id.toString(),\n    };\n  }\n}\n\nexport interface SearchOptions {\n  page: number;\n  pageSize: number;\n  status?: PostQueueStatus | null;\n}\n\nexport interface SearchResult {\n  count: number;\n  data: PostQueueSchemaWithId[];\n}\n\ntype SearchAggregateResult = {\n  count: [{ count: number }];\n  data: LeanPostQueue[];\n}\n*/\n"]}